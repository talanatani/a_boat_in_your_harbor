<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="BLANKET ME" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#000;
      --stageMax: 1200px;
      --stagePad: 40px;

      --portalPages: 2.6;
      --ceremonyPages: 7.4; /* more scroll between lines */

      --mistOpacityMax: 0.55;
      --rainOpacityMax: 0.55;

      --textSize: clamp(16px, 1.6vw, 22px);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; margin:0; }
    body{
      background: var(--bg);
      overflow-x:hidden;
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:#fff;
      position:relative;
    }

    /* =========================
       MIST + OCEAN (hidden until ceremony)
       ========================= */
    .mist{
      position: fixed;
      inset: -20%;
      z-index: 0;
      pointer-events: none;
      opacity: 0;
      filter: blur(26px);
      background:
        radial-gradient(1400px 1200px at 50% 35%, rgba(210,225,255,.16), rgba(0,0,0,0) 68%),
        radial-gradient(1600px 1400px at 50% 80%, rgba(120,150,210,.12), rgba(0,0,0,0) 72%),
        radial-gradient(900px 900px at 15% 55%, rgba(180,190,215,.07), rgba(0,0,0,0) 70%),
        radial-gradient(900px 900px at 85% 45%, rgba(160,180,210,.06), rgba(0,0,0,0) 70%);
      animation: mistDrift 26s ease-in-out infinite alternate;
      transform: translate3d(0,0,0);
      will-change: opacity, transform;
    }
    @keyframes mistDrift{
      0%   { transform: translate3d(-1.2%, -0.8%, 0) scale(1.03); }
      100% { transform: translate3d( 1.2%,  0.8%, 0) scale(1.07); }
    }

    canvas#ocean{
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      opacity: 0;
      filter: blur(0.25px);
      will-change: opacity;
    }

    /* vignette */
    body::after{
      content:"";
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events:none;
      background: radial-gradient(120% 90% at 50% 40%, rgba(0,0,0,0) 52%, rgba(0,0,0,.70) 100%);
      opacity: .65;
    }

    /* =========================
       PORTAL
       ========================= */
    .portal{
      position: relative;
      height: calc(var(--portalPages) * 100vh);
      z-index: 1;
    }
    .portal-stage{
      position: sticky;
      top:0;
      height:100vh;
      display:grid;
      place-items: start center;
      overflow:hidden;
    }
    .portal-inner{
      width: min(var(--stageMax), calc(100vw - var(--stagePad)));
      height:100%;
      position:relative;
      overflow:hidden;
    }
    .portal-inner img{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: contain;
      object-position: top center;
      transform: translate3d(0, var(--y, 0px), 0) scale(1.55);
      transform-origin: top center;
      will-change: transform;
      display:block;
      z-index:1;
    }
    .portal-inner::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background: radial-gradient(120% 85% at 50% 55%, rgba(0,0,0,0) 55%, rgba(0,0,0,.55) 100%);
      z-index:2;
    }

    /* BLANKET ME (never wraps) */
    .invocation{
      position:absolute;
      left:50%;
      top:18%;
      transform: translate(-50%,-50%);
      z-index:3;

      width: max-content;
      max-width: none;
      white-space: nowrap;
      word-break: keep-all;

      font-weight: 500;
      text-transform: uppercase;

      font-size: clamp(22px, 6.2vw, 56px);
      letter-spacing: clamp(.14em, 2.2vw, .26em);

      text-align:center;
      line-height:1;

      color: rgba(255,255,255,.18);
      text-shadow:
        0 0 6px rgba(255,255,255,.32),
        0 0 18px rgba(255,255,255,.20);

      opacity: var(--invOpacity, 1);
      transition: opacity 2.8s ease;
      will-change: opacity;
    }

    /* =========================
       CEREMONY
       ========================= */
    .ceremony{
      position: relative;
      height: calc(var(--ceremonyPages) * 100vh);
      z-index: 1;
    }
    .ceremony-stage{
      position: sticky;
      top:0;
      height:100vh;
      display:grid;
      place-items:center;
      overflow:hidden;
      position: relative; /* needed for void band */
    }

    /* bottom black void band */
    .ceremony-stage::after{
      content:"";
      position:absolute;
      left:0; right:0; bottom:0;
      height: 38vh;
      background: linear-gradient(to bottom,
        rgba(0,0,0,0) 0%,
        rgba(0,0,0,.85) 40%,
        rgba(0,0,0,1) 100%);
      pointer-events:none;
      z-index: 2;
    }

    .ceremony-inner{
      width: min(var(--stageMax), calc(100vw - var(--stagePad)));
      height:100%;
      position:relative;
      display:grid;
      place-items:center;
      z-index: 3;
    }

    /* TEXT LINES — rAF handles smoothness, NO CSS transitions */
    .line{
      position:absolute;
      left:50%;
      transform: translate3d(-50%,0,0);
      text-align:center;

      font-size: var(--textSize);
      line-height: 1.24;
      letter-spacing: .01em;
      font-weight: 400;

      white-space: nowrap;
      max-width:none;

      color: rgba(255,255,255,.90);
      text-shadow:
        0 0 2px rgba(255,255,255,.22),
        0 0 14px rgba(200,220,255,.12),
        0 0 26px rgba(180,200,255,.05);

      opacity: 0;
      filter: blur(1.2px);

      transition: none; /* critical */
      will-change: opacity, filter, transform;

      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
      backface-visibility: hidden;
      transform-style: preserve-3d;

      pointer-events:none;
      z-index: 3;
    }

    /* stations */
    .s1{ top: 18%; }
    .s2{ top: 34%; }
    .s3{ top: 54%; }
    .s4{ top: 70%; }

    /* MOBILE: wrap lines if needed EXCEPT line 1 */
    @media (max-width: 540px){
      .line{ white-space: normal; max-width: 92vw; }
      #l1{ white-space: nowrap; max-width: none; }
    }

    /* ENTER — still a button, but looks like a single word */
    .enter{
      position:absolute;
      left:50%;
      bottom: 14vh; /* inside the black void band */
      transform: translate3d(-50%,0,0);

      background: none;
      border: none;
      padding: 0;

      font-size: 15px;
      letter-spacing: .22em;
      text-transform: lowercase;
      font-weight: 400;

      color: rgba(255,255,255,.85);
      text-shadow:
        0 0 8px rgba(220,235,255,.18),
        0 0 22px rgba(200,220,255,.12);

      cursor: pointer;
      user-select:none;

      opacity: 0;
      transition: opacity 400ms ease;

      z-index: 6; /* above void band overlay */
    }
    .enter:hover{
      opacity: 1;
    }
    .enter:focus{
      outline: none;
    }
  </style>
</head>

<body>
  <div class="mist" id="mist" aria-hidden="true"></div>
  <canvas id="ocean" aria-hidden="true"></canvas>

  <!-- PORTAL -->
  <section class="portal" id="portal">
    <div class="portal-stage">
      <div class="portal-inner">
        <img id="hero" src="new_portal.jpeg" alt="">
        <div class="invocation" id="invocation">BLANKET ME</div>
      </div>
    </div>
  </section>

  <!-- CEREMONY -->
  <section class="ceremony" id="ceremony">
    <div class="ceremony-stage">
      <div class="ceremony-inner">

        <div class="line s1" id="l1">we imagine in this exhibition an invitation to witness our creation of new ways of experiencing boundless love</div>
        <div class="line s2" id="l2">forward-facing and fusing ethereality with inspiration</div>
        <div class="line s3" id="l3">we bear witness and release limitation</div>
        <div class="line s4" id="l4">opening to transformation</div>

        <button class="enter" id="enter" type="button">enter</button>

      </div>
    </div>
  </section>

  <!-- NEXT (optional anchor) -->
  <section id="next" style="height:120vh; background:#000; position:relative; z-index:1;"></section>

  <script>
    /* =========================================================
       OCEAN (rain/ash canvas)
       ========================================================= */
    const ocean = document.getElementById("ocean");
    const ctx = ocean.getContext("2d", { alpha: true });
    const mistEl = document.getElementById("mist");

    let W=0, H=0, DPR=1;
    let drops = [];

    function resizeOcean(){
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = window.innerWidth;
      H = window.innerHeight;

      ocean.width = Math.floor(W * DPR);
      ocean.height = Math.floor(H * DPR);
      ocean.style.width = W + "px";
      ocean.style.height = H + "px";

      ctx.setTransform(DPR,0,0,DPR,0,0);

      const n = Math.max(140, Math.min(360, Math.floor((W*H)/14000)));
      drops = Array.from({length:n}, () => newDrop(true));
    }

    function newDrop(randomY){
      const misty = Math.random() < 0.55;
      return {
        x: Math.random() * W,
        y: randomY ? Math.random() * H : (-200 - Math.random()*H),
        len: misty ? (90 + Math.random()*220) : (50 + Math.random()*160),
        spd: misty ? (0.35 + Math.random()*0.85) : (0.6 + Math.random()*1.3),
        w: misty ? (1.2 + Math.random()*2.2) : (0.8 + Math.random()*1.8),
        a: misty ? (0.018 + Math.random()*0.05) : (0.03 + Math.random()*0.08),
        sway: (-0.18 + Math.random()*0.36)
      };
    }

    function drawOcean(rainBoost=1){
      ctx.clearRect(0,0,W,H);
      ctx.globalCompositeOperation = "lighter";

      for (const d of drops){
        d.y += d.spd * rainBoost;
        d.x += d.sway * 0.18;

        if (d.y - d.len > H){
          d.y = -d.len - 40 - Math.random()*180;
          d.x = Math.random() * W;
        }
        if (d.x < -60) d.x = W + 60;
        if (d.x > W + 60) d.x = -60;

        const g = ctx.createLinearGradient(d.x, d.y, d.x, d.y + d.len);
        g.addColorStop(0, `rgba(255,255,255,0)`);
        g.addColorStop(0.35, `rgba(220,235,255,${d.a})`);
        g.addColorStop(1, `rgba(255,255,255,0)`);

        ctx.strokeStyle = g;
        ctx.lineWidth = d.w;
        ctx.lineCap = "round";

        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(d.x + d.sway*6, d.y + d.len);
        ctx.stroke();
      }

      ctx.globalCompositeOperation = "source-over";
    }

    function loop(){
      drawOcean(window.__rainBoost || 1);
      requestAnimationFrame(loop);
    }

    resizeOcean();
    loop();
    window.addEventListener("resize", () => { resizeOcean(); fitLine1(); }, { passive:true });

    /* =========================================================
       PORTAL + CEREMONY (driven by smoothed progress)
       ========================================================= */
    const hero = document.getElementById("hero");
    const portal = document.getElementById("portal");
    const invocation = document.getElementById("invocation");

    const ceremony = document.getElementById("ceremony");
    const lines = [
      document.getElementById("l1"),
      document.getElementById("l2"),
      document.getElementById("l3"),
      document.getElementById("l4"),
    ];
    const enter = document.getElementById("enter");

    function smoothstep(x){
      x = Math.min(1, Math.max(0, x));
      return x*x*(3 - 2*x);
    }

    // keep l1 as a single line on mobile by scaling down if needed
    function fitLine1(){
      const el = lines[0];
      if (!el) return;

      el.style.transform = "translate3d(-50%,0,0) scale(1)";

      const maxW = Math.min(window.innerWidth * 0.92, 1200);
      const w = el.scrollWidth;

      if (w > maxW){
        const s = Math.max(0.72, Math.min(1, maxW / w));
        el.style.transform = `translate3d(-50%,0,0) scale(${s.toFixed(3)})`;
      }
    }

    function portalScroll(p){
      const vh = window.innerHeight;

      const driftPx = vh * 0.28;
      const y = (0.5 - p) * 2 * driftPx;
      hero.style.setProperty("--y", `${y}px`);

      const fadeEnd = 0.78;
      const t = Math.min(1, p / fadeEnd);
      invocation.style.setProperty("--invOpacity", (1 - t).toFixed(3));
    }

    function ceremonyScroll(p){
      // “better” ramp: no rain until ceremony begins, then baseline + intensify
      const rainIn = smoothstep((p - 0.05) / 0.35);

      const rainMax = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--rainOpacityMax")) || 0.55;
      const mistMax = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--mistOpacityMax")) || 0.55;

      const rainOpacity = (rainIn <= 0.001) ? 0 : (0.18 + rainIn * rainMax);
      ocean.style.opacity = rainOpacity.toFixed(3);
      window.__rainBoost = 1 + rainIn * 1.15;

      const mistOpacity = (rainIn <= 0.001) ? 0 : (0.10 + rainIn * mistMax);
      mistEl.style.opacity = Math.min(0.85, mistOpacity).toFixed(3);

      // one-line-at-a-time sequencing
      const n = lines.length;
      const seg = 1 / (n + 1.35);

      const inStart = 0.16;
      const outStart = 0.56;

      for (let i=0; i<n; i++){
        const start = i * seg;
        const local = (p - start) / (seg || 1);

        let alpha = 0;

        if (local >= inStart && local <= outStart){
          const tIn = (local - inStart) / (outStart - inStart);
          alpha = smoothstep(tIn);
        }
        if (local > outStart){
          const tOut = (local - outStart) / (1 - outStart);
          alpha = 1 - smoothstep(tOut);
        }

        alpha = Math.max(0, Math.min(1, alpha));
        lines[i].style.opacity = alpha.toFixed(3);
        lines[i].style.filter = `blur(${(1.2 * (1 - alpha)).toFixed(2)}px)`;
      }

      // breath before enter
      const enterStart = (n * seg) + 0.08;
      const enterAlpha = smoothstep((p - enterStart) / 0.18);
      enter.style.opacity = enterAlpha.toFixed(3);

      fitLine1();

      // ---- FINAL REST STATE (prevents "everything disappears") ----
      if (p > 0.985){
        lines.forEach(l => {
          l.style.opacity = "0";
          l.style.filter = "blur(1.2px)";
        });
        enter.style.opacity = "1";  // ✅ always visible at the end
      }
    }

    /* =========================================================
       SMOOTH SCROLL DRIVER (prevents glitchy fades)
       ========================================================= */
    function getProgress(el){
      const rect = el.getBoundingClientRect();
      const vh = window.innerHeight;
      const total = rect.height - vh;
      return Math.min(1, Math.max(0, (-rect.top) / (total || 1)));
    }
    function lerp(a,b,t){ return a + (b-a)*t; }

    let __ticking = false;
    let __portalTarget = 0, __portalNow = 0;
    let __cerTarget = 0, __cerNow = 0;

    function captureTargets(){
      __portalTarget = getProgress(portal);
      __cerTarget = getProgress(ceremony);
    }

    function tick(){
      __portalNow = lerp(__portalNow, __portalTarget, 0.12);
      __cerNow    = lerp(__cerNow,    __cerTarget,    0.12);

      portalScroll(__portalNow);
      ceremonyScroll(__cerNow);

      __ticking = false;

      if (Math.abs(__portalNow-__portalTarget) > 0.0008 || Math.abs(__cerNow-__cerTarget) > 0.0008){
        __ticking = true;
        requestAnimationFrame(tick);
      }
    }

    function onScroll(){
      captureTargets();
      if (!__ticking){
        __ticking = true;
        requestAnimationFrame(tick);
      }
    }

    window.addEventListener("scroll", onScroll, { passive:true });

    window.addEventListener("load", () => {
      fitLine1();
      captureTargets();
      tick();
    });

    captureTargets();
    tick();

    /* ENTER BUTTON ACTION */
    enter.addEventListener("click", () => {
      // If you want "no next yet", you can make it just glow or do nothing.
      // For now: scroll to black anchor (safe).
      const next = document.getElementById("next");
      if (next) next.scrollIntoView({ behavior: "smooth", block: "start" });
    });
  </script>
</body>
</html>
